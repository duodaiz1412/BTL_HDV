{"ast":null,"code":"var _jsxFileName = \"D:\\\\BTL_HDV\\\\mid-project-379283427\\\\frontend\\\\src\\\\components\\\\NotificationProvider.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext } from 'react';\nimport { ToastContainer, toast } from 'react-toastify';\nimport 'react-toastify/dist/ReactToastify.css';\nimport { getNotifications, markNotificationAsRead } from '../services/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst NotificationContext = /*#__PURE__*/createContext();\nexport const useNotifications = () => {\n  _s();\n  return useContext(NotificationContext);\n};\n_s(useNotifications, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const NotificationProvider = ({\n  children\n}) => {\n  _s2();\n  const [socket, setSocket] = useState(null);\n  const [notifications, setNotifications] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [socketStatus, setSocketStatus] = useState('disconnected');\n\n  // Lấy thông báo ban đầu từ API\n  useEffect(() => {\n    const customerId = localStorage.getItem('customer_id');\n    if (customerId) {\n      const fetchNotifications = async () => {\n        try {\n          const response = await getNotifications();\n          console.log('Dữ liệu thông báo đã tải:', response.data);\n          setNotifications(response.data || []);\n        } catch (error) {\n          console.error('Lỗi khi lấy thông báo:', error);\n        } finally {\n          setLoading(false);\n        }\n      };\n      fetchNotifications();\n    } else {\n      setLoading(false);\n    }\n  }, []);\n\n  // Kết nối WebSocket để nhận thông báo realtime\n  useEffect(() => {\n    console.log('Bắt đầu kết nối WebSocket...');\n    const customerId = localStorage.getItem('customer_id');\n    if (!customerId) {\n      console.log('Không tìm thấy customer_id, không thể kết nối WebSocket');\n      setSocketStatus('no customer_id');\n      return;\n    }\n\n    // Kết nối đến WebSocket server\n    const socketUrl = `ws://localhost:800/ws/notifications/${customerId}`;\n    console.log('Kết nối đến:', socketUrl);\n    const ws = new WebSocket(socketUrl);\n    setSocket(ws);\n\n    // Xử lý các sự kiện WebSocket\n    ws.onopen = () => {\n      console.log('Kết nối WebSocket đã mở');\n      setSocketStatus('connected');\n    };\n    ws.onmessage = event => {\n      const data = JSON.parse(event.data);\n      console.log('Nhận tin nhắn WebSocket:', data);\n      if (data.event === 'connection_established') {\n        console.log('Kết nối thành công với ID:', data.id);\n      } else if (data.event === 'unread_notifications') {\n        console.log('Nhận thông báo chưa đọc:', data.data);\n        // Cập nhật danh sách thông báo (nối thêm vào danh sách hiện tại)\n        setNotifications(prev => {\n          // Lọc ra các thông báo không trùng lặp\n          const existingIds = new Set(prev.map(n => n._id));\n          const newNotifications = data.data.filter(n => !existingIds.has(n._id));\n          return [...prev, ...newNotifications];\n        });\n      } else if (data.event === 'new_notification') {\n        console.log('Nhận thông báo mới:', data.data);\n\n        // Hiển thị toast thông báo\n        toast.success(data.data.content, {\n          position: \"top-right\",\n          autoClose: 5000,\n          hideProgressBar: false,\n          closeOnClick: true,\n          pauseOnHover: true,\n          draggable: true\n        });\n\n        // Cập nhật danh sách thông báo\n        setNotifications(prev => [data.data, ...prev]);\n      } else if (data.event === 'notification_marked_read') {\n        console.log('Thông báo đã được đánh dấu đã đọc:', data.data);\n      } else if (data.event === 'ping') {\n        // Nhận ping từ server, không cần xử lý gì\n        console.log('Nhận ping từ server');\n      }\n    };\n    ws.onerror = error => {\n      console.error('Lỗi WebSocket:', error);\n      setSocketStatus('error');\n    };\n    ws.onclose = event => {\n      console.log('WebSocket đã đóng:', event.code, event.reason);\n      setSocketStatus('disconnected');\n\n      // Thử kết nối lại sau 5 giây nếu mất kết nối đột ngột\n      if (event.code !== 1000) {\n        // 1000 là mã đóng bình thường\n        console.log('Sẽ thử kết nối lại sau 5 giây...');\n        setTimeout(() => {\n          setSocketStatus('reconnecting');\n        }, 5000);\n      }\n    };\n\n    // Gửi lệnh khi đóng component\n    return () => {\n      console.log('Đóng kết nối WebSocket');\n      if (ws && ws.readyState === WebSocket.OPEN) {\n        ws.close();\n      }\n    };\n  }, [socketStatus === 'reconnecting']); // Thử kết nối lại khi trạng thái là reconnecting\n\n  // Debug: Hiển thị thông báo trong console mỗi khi socketStatus thay đổi\n  useEffect(() => {\n    console.log('Trạng thái Socket:', socketStatus);\n  }, [socketStatus]);\n\n  // Đánh dấu thông báo đã đọc\n  const handleMarkAsRead = async notificationId => {\n    try {\n      // Gọi API để đánh dấu đã đọc\n      await markNotificationAsRead(notificationId);\n\n      // Cập nhật trạng thái trong context\n      setNotifications(notifications.map(n => n._id === notificationId ? {\n        ...n,\n        status: 'read'\n      } : n));\n\n      // Gửi lệnh đánh dấu đã đọc qua WebSocket nếu kết nối đang mở\n      if (socket && socket.readyState === WebSocket.OPEN) {\n        socket.send(JSON.stringify({\n          command: 'mark_read',\n          notification_id: notificationId\n        }));\n      }\n    } catch (error) {\n      console.error('Lỗi khi đánh dấu thông báo đã đọc:', error);\n    }\n  };\n\n  // Đảm bảo context luôn có giá trị mới nhất\n  const contextValue = {\n    notifications,\n    loading,\n    socketStatus,\n    markAsRead: handleMarkAsRead\n  };\n  return /*#__PURE__*/_jsxDEV(NotificationContext.Provider, {\n    value: contextValue,\n    children: [children, /*#__PURE__*/_jsxDEV(ToastContainer, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 169,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 167,\n    columnNumber: 5\n  }, this);\n};\n_s2(NotificationProvider, \"4n/h08Rh30GQowf5KDzPaxyAk8g=\");\n_c = NotificationProvider;\nexport default NotificationProvider;\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","ToastContainer","toast","getNotifications","markNotificationAsRead","jsxDEV","_jsxDEV","NotificationContext","useNotifications","_s","NotificationProvider","children","_s2","socket","setSocket","notifications","setNotifications","loading","setLoading","socketStatus","setSocketStatus","customerId","localStorage","getItem","fetchNotifications","response","console","log","data","error","socketUrl","ws","WebSocket","onopen","onmessage","event","JSON","parse","id","prev","existingIds","Set","map","n","_id","newNotifications","filter","has","success","content","position","autoClose","hideProgressBar","closeOnClick","pauseOnHover","draggable","onerror","onclose","code","reason","setTimeout","readyState","OPEN","close","handleMarkAsRead","notificationId","status","send","stringify","command","notification_id","contextValue","markAsRead","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/BTL_HDV/mid-project-379283427/frontend/src/components/NotificationProvider.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext } from 'react';\nimport { ToastContainer, toast } from 'react-toastify';\nimport 'react-toastify/dist/ReactToastify.css';\nimport { getNotifications, markNotificationAsRead } from '../services/api';\n\nconst NotificationContext = createContext();\n\nexport const useNotifications = () => useContext(NotificationContext);\n\nexport const NotificationProvider = ({ children }) => {\n  const [socket, setSocket] = useState(null);\n  const [notifications, setNotifications] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [socketStatus, setSocketStatus] = useState('disconnected');\n\n  // Lấy thông báo ban đầu từ API\n  useEffect(() => {\n    const customerId = localStorage.getItem('customer_id');\n    if (customerId) {\n      const fetchNotifications = async () => {\n        try {\n          const response = await getNotifications();\n          console.log('Dữ liệu thông báo đã tải:', response.data);\n          setNotifications(response.data || []);\n        } catch (error) {\n          console.error('Lỗi khi lấy thông báo:', error);\n        } finally {\n          setLoading(false);\n        }\n      };\n      fetchNotifications();\n    } else {\n      setLoading(false);\n    }\n  }, []);\n\n  // Kết nối WebSocket để nhận thông báo realtime\n  useEffect(() => {\n    console.log('Bắt đầu kết nối WebSocket...');\n    \n    const customerId = localStorage.getItem('customer_id');\n    if (!customerId) {\n      console.log('Không tìm thấy customer_id, không thể kết nối WebSocket');\n      setSocketStatus('no customer_id');\n      return;\n    }\n    \n    // Kết nối đến WebSocket server\n    const socketUrl = `ws://localhost:800/ws/notifications/${customerId}`;\n    console.log('Kết nối đến:', socketUrl);\n    \n    const ws = new WebSocket(socketUrl);\n    setSocket(ws);\n    \n    // Xử lý các sự kiện WebSocket\n    ws.onopen = () => {\n      console.log('Kết nối WebSocket đã mở');\n      setSocketStatus('connected');\n    };\n    \n    ws.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      console.log('Nhận tin nhắn WebSocket:', data);\n      \n      if (data.event === 'connection_established') {\n        console.log('Kết nối thành công với ID:', data.id);\n      } \n      else if (data.event === 'unread_notifications') {\n        console.log('Nhận thông báo chưa đọc:', data.data);\n        // Cập nhật danh sách thông báo (nối thêm vào danh sách hiện tại)\n        setNotifications(prev => {\n          // Lọc ra các thông báo không trùng lặp\n          const existingIds = new Set(prev.map(n => n._id));\n          const newNotifications = data.data.filter(n => !existingIds.has(n._id));\n          return [...prev, ...newNotifications];\n        });\n      }\n      else if (data.event === 'new_notification') {\n        console.log('Nhận thông báo mới:', data.data);\n        \n        // Hiển thị toast thông báo\n        toast.success(data.data.content, {\n          position: \"top-right\",\n          autoClose: 5000,\n          hideProgressBar: false,\n          closeOnClick: true,\n          pauseOnHover: true,\n          draggable: true,\n        });\n        \n        // Cập nhật danh sách thông báo\n        setNotifications(prev => [data.data, ...prev]);\n      }\n      else if (data.event === 'notification_marked_read') {\n        console.log('Thông báo đã được đánh dấu đã đọc:', data.data);\n      }\n      else if (data.event === 'ping') {\n        // Nhận ping từ server, không cần xử lý gì\n        console.log('Nhận ping từ server');\n      }\n    };\n    \n    ws.onerror = (error) => {\n      console.error('Lỗi WebSocket:', error);\n      setSocketStatus('error');\n    };\n    \n    ws.onclose = (event) => {\n      console.log('WebSocket đã đóng:', event.code, event.reason);\n      setSocketStatus('disconnected');\n      \n      // Thử kết nối lại sau 5 giây nếu mất kết nối đột ngột\n      if (event.code !== 1000) { // 1000 là mã đóng bình thường\n        console.log('Sẽ thử kết nối lại sau 5 giây...');\n        setTimeout(() => {\n          setSocketStatus('reconnecting');\n        }, 5000);\n      }\n    };\n    \n    // Gửi lệnh khi đóng component\n    return () => {\n      console.log('Đóng kết nối WebSocket');\n      if (ws && ws.readyState === WebSocket.OPEN) {\n        ws.close();\n      }\n    };\n  }, [socketStatus === 'reconnecting']); // Thử kết nối lại khi trạng thái là reconnecting\n\n  // Debug: Hiển thị thông báo trong console mỗi khi socketStatus thay đổi\n  useEffect(() => {\n    console.log('Trạng thái Socket:', socketStatus);\n  }, [socketStatus]);\n\n  // Đánh dấu thông báo đã đọc\n  const handleMarkAsRead = async (notificationId) => {\n    try {\n      // Gọi API để đánh dấu đã đọc\n      await markNotificationAsRead(notificationId);\n      \n      // Cập nhật trạng thái trong context\n      setNotifications(notifications.map(n => \n        n._id === notificationId ? { ...n, status: 'read' } : n\n      ));\n      \n      // Gửi lệnh đánh dấu đã đọc qua WebSocket nếu kết nối đang mở\n      if (socket && socket.readyState === WebSocket.OPEN) {\n        socket.send(JSON.stringify({\n          command: 'mark_read',\n          notification_id: notificationId\n        }));\n      }\n    } catch (error) {\n      console.error('Lỗi khi đánh dấu thông báo đã đọc:', error);\n    }\n  };\n\n  // Đảm bảo context luôn có giá trị mới nhất\n  const contextValue = {\n    notifications,\n    loading,\n    socketStatus,\n    markAsRead: handleMarkAsRead\n  };\n\n  return (\n    <NotificationContext.Provider value={contextValue}>\n      {children}\n      <ToastContainer />\n    </NotificationContext.Provider>\n  );\n};\n\nexport default NotificationProvider; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}